# -*- coding: utf-8 -*-
"""backtester module

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Sy6hp-5vFVMJOzNjz8BMHQwVFkiGNdwe

# **BACKTESTER MODULE**
"""

#SET UP LIBRARIES + ENVIRONMENT

!pip install pyfolio
!pip install theano
!pip install pymc3

## to counter theano library problems + zipline needed for pyfolio

import os

# Set the MKL_THREADING_LAYER environment variable
os.environ["MKL_THREADING_LAYER"] = "GNU"


!pip install zipline

import pyfolio as pf
import pandas as pd
from datetime import datetime

class backtesting():
    def __init__(self,start,end):

      data=read_stock_data_from_csv("/content/cac40_stock_data.csv",[
      "AC.PA", "AI.PA", "AIR.PA", "ALO.PA", "ATO.PA", "CS.PA", "BNP.PA",
      "EN.PA", "CAP.PA", "CA.PA", "ACA.PA", "BN.PA", "DSY.PA", "ENGI.PA", "EL.PA",
      "RMS.PA", "KER.PA", "OR.PA", "LR.PA", "MC.PA", "ML.PA", "ORA.PA", "RI.PA",
     "PUB.PA", "RNO.PA", "SAF.PA", "SGO.PA", "SAN.PA", "SU.PA", "GLE.PA",
      "TEP.PA", "HO.PA", "TTE.PA", "VIE.PA", "VIV.PA"],start,end)


      #self.log_return= np.log(data.iloc[0]  / data.iloc[-1] ) * poids["Weights"].squeeze()

      self.daily_return=np.log(data/data.shift(1))

      # Multiply each stock return by its weight in the portfolio
      weighted_returns = self.daily_return * poids['Weights'].values

      equal_returns=self.daily_return*1/35

      # Calculate portfolio return by summing the weighted returns for each date
      self.portfolio_return = weighted_returns.sum(axis=1)


    def results(self):

     # print(self.daily_return)
     # print(self.portfolio_return)

      results = pf.create_simple_tear_sheet(self.portfolio_return.squeeze())
      return results

    def expected_return (self):

      exp_r_opt=self.daily_return.sum().apply(lambda x : x*256/len(self.daily_return)).to_numpy()

      exp_r_eq=self.equal_return.sum().apply(lambda x : x*256/len(self.equal_returns)).to_numpy()

      return(exp_r_opt,exp_r_eq)

    def covariance (self):
      cov_opt=self.daily_return.cov().apply(lambda x: x *256).to_numpy()
      cov_eq=self.equal_return.cov().apply(lambda x: x *256).to_numpy()

      return(cov_opt,cov_eq)


    def plot_returns(self):
    # Plotting daily returns for each stock
      plt.figure(figsize=(12, 8))
      plt.title("expected return and covariance of optimal ptf ")
      for column in self.daily_return.columns:
          plt.plot(self.daily_return.index, self.daily_return[column], label=column)

      plt.xlabel("Date")
      plt.ylabel("Daily Return")
      plt.legend(loc="upper left")
      plt.show()

      # Plotting equal returns for each stock
      plt.figure(figsize=(12, 8))
      plt.title("Equal Returns for Each Stock")
      for column in self.equal_returns.columns:
          plt.plot(self.equal_returns.index, self.equal_returns[column], label=column)

      plt.xlabel("Date")
      plt.ylabel("Equal Return")
      plt.legend(loc="upper left")
      plt.show()

#résumé de la conversation téléphonique. En input il y a ,depuis la partie de Sidan/Ayah, un df avec en colonne 1 les dates et dans chaque autre colonne le cours de chaque action
# ; depuis la partie de Pierre, un df avec en colonne 1 le ticker des actions, en colonne 2 le poids dans le portefeuille optimal
# le but est de calculer sur une période disjointe de la période de calibration, le return et le risk du portefeuille (se mettre d'accord sur les métriques retenues) et de tracer son cours
# ça peut être bien de comparer si possible à un benchmark qui serait l'univers d'investissement équipondéré

print(retrieved_data.index.values.dtype)

start='2015-01-01'
end='2018-12-31'

csv_handler = CSV_handler()
data=csv_handler.read_stock_data_from_csv("/content/cac40_stock_data.csv",[
      "AC.PA", "AI.PA", "AIR.PA", "ALO.PA", "ATO.PA", "CS.PA", "BNP.PA",
      "EN.PA", "CAP.PA", "CA.PA", "ACA.PA", "BN.PA", "DSY.PA", "ENGI.PA", "EL.PA",
      "RMS.PA", "KER.PA", "OR.PA", "LR.PA", "MC.PA", "ML.PA", "ORA.PA", "RI.PA",
     "PUB.PA", "RNO.PA", "SAF.PA", "SGO.PA", "SAN.PA", "SU.PA", "GLE.PA",
      "TEP.PA", "HO.PA", "TTE.PA", "VIE.PA", "VIV.PA"],start,end)

print(data.isnull().any())

np.log(data.iloc[0]  / data.iloc[-1] ).head()

start='2015-01-01'
end='2018-12-31'

backtester=backtesting(start,end)
print(backtester.results())
print(backtester.expected_return())
print(backtester.covariance())